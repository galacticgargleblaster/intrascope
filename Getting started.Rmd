---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 1.0.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from requests_oauthlib import OAuth2Session
from oauthlib.oauth2 import BackendApplicationClient
from requests.auth import HTTPBasicAuth
import time
import os
from urllib.parse import urljoin
import pandas as pd
import datetime
from datetime import datetime as dt
from matplotlib import pyplot as plt
from tqdm.auto import tqdm
import re

CAMPUS = "Fremont"
REQUESTS_PER_SECOND = 2
```

# Storing Secrets in Environment Variables

While there exist better ways of storing secrets, this one is the bare minimum needed to distribute a notebook for public use.

1. Create a file called `.env`, and copy your API keys into it like so:

        INTRA_UID=fffffffffffffffffffffffffffffff
        INTRA_SECRET=fffffffffffffffffffffffffffff

2. You may then export the environment variables so that they're available for the jupyter notebook server to access
`export `cat .env` && jupyter notebook`


```{python}
client_id = os.environ['INTRA_UID']
client_secret = os.environ['INTRA_SECRET']

URL_BASE = 'https://api.intra.42.fr/'
APIV2 = urljoin(URL_BASE, 'v2/')

token_url = urljoin(URL_BASE, 'oauth/token')
auth = HTTPBasicAuth(client_id, client_secret)
client = BackendApplicationClient(client_id=client_id)
oauth = OAuth2Session(client=client)
token_info = oauth.fetch_token(token_url=token_url, auth=auth, client_id=client_id, client_secret=client_secret)
token =  token_info["access_token"]
```

# Getting to know the place

Let's have a look at your last 30 logins

```{python}
YOU = os.environ['USER']
res = oauth.get(urljoin(APIV2, f'users/{YOU}/locations'))
```

```{python}
logins = pd.DataFrame.from_dict(res.json())
logins[0:5]
```

The session begin/end times are recorded in ISO 8601 datetime format.  The ['Z' means it's in UTC](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) -- Coordinated Universal Time.  

If the login tracking service is working properly, row 0 will show `end_at` is `None`, meaning you're currently logged in!

Let's see the amount of time you've been logged in on different hosts in the last 30 sessions:

```{python}
fmt = '%Y-%m-%dT%H:%M:%S.%fZ'

total_time = datetime.timedelta()
time_by_host = {}
duration_by_session = {}

for login in logins.itertuples():
    if not login.end_at:
        end = dt.now()  # You're currently logged in!
    else:
        end = dt.strptime(login.end_at, fmt)
    begin = dt.strptime(login.begin_at, fmt)
    delta = end - begin
    total_time += delta
    duration_by_session[login.id] = delta
    if time_by_host.get(login.host):
        time_by_host[login.host] += delta
    else:
        time_by_host[login.host] = delta

# Convert the datetime.timedelta objects to floats
time_by_host = {host: t.total_seconds()/3600 for host, t in time_by_host.items()}
duration_by_session = {session: t.total_seconds()/3600 for session, t in duration_by_session.items()}

pie = plt.pie(x=list(time_by_host.values()), 
               labels = list(time_by_host.keys()),
               autopct='%.1f Hrs')
out_fmt = '%b %d'
start_approx = dt.strptime(logins.begin_at[len(logins) - 1], fmt).strftime(out_fmt)
end_approx = dt.strptime(logins.begin_at[0], fmt).strftime(out_fmt)
plt.title(f"Login time by host from {start_approx} to {end_approx}");

```

# Bigger Questions

- What is the average session duration in zones 2 3 and 4?
- What is the duration of study of cadet by zone? (avg, std dev)
    - Level?
- How does the number of hours logged by cadets vary by season?

```{python}
res = oauth.get(urljoin(APIV2, f'campus'))
try:
    our_campus_id = next(campus.get("id") for campus in res.json() if campus.get("name") == CAMPUS)
except StopIteration:
    print(f"Can't find {CAMPUS} campus ID")
    raise
res = oauth.get(urljoin(APIV2, f'campus/{our_campus_id}/users'))
print(f'There are {res.headers["X-Total"]} students in the registration history of the {CAMPUS} campus.')
```

```{python}
res = oauth.get(urljoin(APIV2, f'campus/{our_campus_id}/locations'))
```

```{python}
total_sessions = res.headers["X-Total"]
oldest_page = res.headers["X-Page"]
sessions_per_page = res.headers["X-Per-Page"]
```

That's quite a lot.  Our default rate-limit also sucks.
[Although the API documentation indicates it might be possible](https://api.intra.42.fr/apidoc/guides/specification#pagination), asking for more (or fewer) than 30 items doesn't seem to work at time of writing.

```{python}
TIME_BETWEEN_REQUESTS = 1/REQUESTS_PER_SECOND

sessions = pd.DataFrame.from_dict(res.json())
page = 1
while (page < 100):
    start_time = time.time()
    try:
        res = oauth.get(urljoin(APIV2, f'campus/{our_campus_id}/locations?page={page}'))
    except Exception as e:
        print(f"Failed with exception:{e}\n\nbreaking to preserve whatever data we've got so far")
        break
    if (res.ok):
        print(f"grabbed page {page}")
        sessions = sessions.append(pd.DataFrame.from_dict(res.json()), ignore_index=True)
        page += 1
        if (int(res.headers['X-Hourly-RateLimit-Remaining']) < 1):
            import ipdb; ipdb.set_trace()
    else:
        print(f"request failed: {res}")
    elapsed_time = time.time() - start_time
    time.sleep(max(TIME_BETWEEN_REQUESTS - elapsed_time, 0))   
```

```{python}
sessions = pd.read_pickle('sessions')

def strptime_wrapper(string, args):
    try:
        return dt.strptime(string, args)
    except TypeError:
        return None

sessions.begin_at = sessions.begin_at.apply(strptime_wrapper, args=(fmt,))
sessions.end_at = sessions.end_at.apply(strptime_wrapper, args=(fmt,))

```

```{python}
mask_by_zone = {n : sessions.host.apply(lambda x: x[3] == n) for n in ['2','3','4']}
```

```{python}
def mean_by_zone(n):
    s = sessions[mask_by_zone[str(n)]]
    d = s.end_at - s.begin_at
    return d.mean()


```

```{python}
out_fmt = '%b %d'

end = sessions.end_at.max().strftime(out_fmt)
begin = sessions.begin_at.min().strftime(out_fmt)
print(f"from {begin} to {end}:")
[print(f"Mean session duration for zone {z}: {(mean_by_zone(z).seconds/3600):.2f} hrs") for z in [2,3,4]]
```
